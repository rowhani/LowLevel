TITLE ARTMAN FLOPPY DISK READER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;This program is a fat-12 floppy-disk reader developed by Artman Systems Inc.
;;This prgram is like HDR but doesn't have  DRIVE_MANAGER, PARTITION_READER and DIVISION.
;;It gets a /B switch to let the prgram read from drive B:
;;Only  FAT_CLUS_ENT is changed, look at the procedure for more information.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


STACKSEG SEGMENT STACK 'STACK'
	MSTACK DW 100 DUP(?)
STACKSEG ENDS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 
DATASEG SEGMENT 'DATA'		
		
		;BOOT RECORD DATA
		BOOT_RECORD LABEL BYTE
		JMPDATA DB 3 DUP(?)
		MN_VER DB 8 DUP(?)
		BYTE_PER_SEC DW ?
		SEC_PER_CLUS DB ?
		RES_SEC DW ?
		FATS DB ?
		DIR_ENTRIES DW ?
		SIZE_SEC_SMALL DW ?
		MEDIA_TYPE DB ?
		FAT_SECTS12 DW ?
		SEC_PER_CYL DW ?
		HEADSNO DW ?
		HIDDEN_SEC DD ?
		SIZE_SEC_BIG DD ?
		FAT_SECTS32 DD ?
		BOOT_REST DB 472 DUP(?)
		
		;CONVERT DATA
		LOGIC_SECTOR DD ?
		SECTOR DB ?
		CYLINDER DB ?
		HEAD DB ?
		NSEC DB ?
		SEC_BUFFER DB 2*512 DUP(0)

		;CLUSTER DATA
		RESERVED_BYTES DW ?
		CLUSTER DW ?
		
		;FAT DATA
		BUF_FLAG DB ?
		FAT_BUFFER DW 256 DUP(?) 
		
		;DIRECTORY AND SUBDIRECTORY DATA
		NAMEARG DB 12 DUP(' ')
		DIR_BUFFER DD 128 DUP(?)
		FILE_FLAG DB ?	
		ROOT_FLAG DB ?		
		DIR_FLAG DB ?
		FILEERROR DB "FILE NOT FOUND.$"
		DIRERROR DB "PATH NOT SPECIFIED.$"
		FATALERROR DB "FATAL ERROR: UNABLE TO READ FROM THE DEVICE.$"
		DRIVE DB 0					;=1 as Drive A: and =0 as Drive B:
		PARITY DB 0					;used to see whether cluster is odd or even
		
		;MAIN DATA
		PROMPT DB " ARTMAN SYSTEMS INC.",10,13," LOW LEVEL FILE READER VERSION 1.0",10,13,10,13,
		"     FDR [path][filename] [/B]",10,13,10,13,10,13,"   /B        USES B: AS FLOPPY DRIVE.$"
		PATHLEN DB ?
		PATH DB 81 DUP(0)
		TKNPT DB 0
		PRT_FLAG DB 0DH
		AS_BIN_FLAG DB 1
DATASEG ENDS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CODESEG SEGMENT 'CODE'


ASSUME CS:CODESEG, DS:DATASEG, SS:STACKSEG, ES:DATASEG
	
BOOT_RECORD_READER PROC NEAR
	
	MOV AH,2
	MOV AL,1
	MOV CH,0
	MOV CL,1
	MOV DH,0
	MOV DL, DRIVE
	LEA BX, BOOT_RECORD
	INT 13H
	JC READERROR
	
	RET
BOOT_RECORD_READER ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LOGICAL_TO_PHYSICAL_SECONT PROC NEAR

	MOV DX, WORD PTR LOGIC_SECTOR[2]
	MOV AX, WORD PTR LOGIC_SECTOR
	
	ADD AX,1
	ADC DX,0

	MOV BX, SEC_PER_CYL
	DIV BX 
	
	MOV SECTOR,DL
	
	XOR DX,DX
	MOV BX, HEADSNO
	DIV BX
	
	MOV HEAD,DL				;****
	
	MOV CYLINDER,AL			;****
	MOV BL,40H
	MOV AL,AH
	MUL BL
	
	ADD SECTOR, AL			;****
	
	MOV AH,2
	MOV AL, NSEC
	MOV CH, CYLINDER
	MOV CL, SECTOR
	MOV DH, HEAD
	MOV DL, DRIVE
	CMP BUF_FLAG,0
	JE PUTSEC
	CMP BUF_FLAG,1
	JE PUTFAT
	LEA BX, DIR_BUFFER
	JMP DONEF	
	PUTSEC:
	LEA BX, SEC_BUFFER
	JMP DONEF
	PUTFAT:
	LEA BX, FAT_BUFFER	
	DONEF:
	INT 13H
	JC READERROR
	
	RET
LOGICAL_TO_PHYSICAL_SECONT ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CLUSTER_FINDER PROC NEAR

	XOR BH,BH
	MOV BL, FATS
	MOV AX, FAT_SECTS12
	MUL BX
	
	ADD AX, RES_SEC
	ADC DX,0
	
	MOV BX, DIR_ENTRIES
	MOV CL, 4
	SHR BX, CL
	
	ADD AX, BX
	ADC DX,0
	
	MOV BX, 0	
	MOV CX, 0
		
	ADD BX,AX
	ADC CX,DX
	
	MOV AX, CLUSTER
	SUB AX,2
	PUSH AX
	XOR AH,AH
	MOV AL,SEC_PER_CLUS
	MOV SI, AX
	POP AX
	MUL SI
	
	ADD BX,AX
	ADC CX,DX
	
	MOV WORD PTR LOGIC_SECTOR, BX
	MOV WORD PTR LOGIC_SECTOR[2], CX
	
	MOV AL, SEC_PER_CLUS
	MOV NSEC, AL
	
	MOV BUF_FLAG, 0
	CALL LOGICAL_TO_PHYSICAL_SECONT
	
	RET
CLUSTER_FINDER ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FAT_CLUS_ENT PROC NEAR

	MOV AX, CLUSTER
	SHR AX,1
	MOV PARITY,0				;parity=0 if the cluster is even and =1 if it is odd.
	ADC PARITY,0
	ADD CLUSTER,AX
	
	XOR DX,DX
	MOV AX, CLUSTER
	MOV BX,512
	DIV BX
	MOV BX,DX
	PUSH BX
	
	XOR CX,CX
	
	ADD AX, RES_SEC
	ADC CX,0
	
	MOV WORD PTR LOGIC_SECTOR, AX
	MOV WORD PTR LOGIC_SECTOR[2], CX
	MOV NSEC,1
	MOV BUF_FLAG, 1
	CALL LOGICAL_TO_PHYSICAL_SECONT
	
	POP BX
	MOV AX, FAT_BUFFER[BX]
	CMP PARITY, 0
	JE EVENA
	;AND AX, 0FFF0H
	MOV CL,4						;if parity=1 then get the most significant 12 bits of 16 bits by shifting it 4 times to right
	SHR AX,CL
	JMP DOCLUS
	EVENA:
	AND AX,00FFFH					;if parity=0 then get the least significant 12 bits of 16 bits
	DOCLUS:
	MOV CLUSTER, AX
	
	RET
FAT_CLUS_ENT ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DIR_ENT PROC NEAR	
	MOV BX,0
	MOV CX,0
	
	ADD BX, RES_SEC
	ADC CX,0
	
	PUSH CX
	XOR CH,CH
	MOV AX, FAT_SECTS12
	MOV CL, FATS
	MUL CX	
	POP CX
	
	ADD BX, AX
	ADC CX, DX
	
	MOV WORD PTR LOGIC_SECTOR, BX
	MOV WORD PTR LOGIC_SECTOR[2], CX	
	
	MOV AX, DIR_ENTRIES
	MOV CL, 4
	SHR AX, CL
	
	XOR DX,DX
	MOV BUF_FLAG, 2
	MOV NSEC,1
	GETNEXTSEC:	
	PUSH DX
	PUSH AX
	CALL LOGICAL_TO_PHYSICAL_SECONT
	ADD WORD PTR LOGIC_SECTOR, 1
	ADC WORD PTR LOGIC_SECTOR[2], 0
	POP AX
	POP DX
	INC DX
	CMP DX, AX
	JE NOTFOUND
	
	XOR BX,BX
	NEXTENT:
	CLD
	LEA SI, NAMEARG
	LEA DI, DIR_BUFFER[BX]
	MOV BP,DI
	MOV CX,11
	REPE CMPSB
	JE FOUND
	ADD BX,32
	CMP BX, 512
	JE GETNEXTSEC
	JMP NEXTENT
	
	NOTFOUND:
	MOV FILE_FLAG,0
	JMP ERRORPRN
	
	FOUND:
	MOV FILE_FLAG,1
	ADD BP,26
	MOV BX, BP
	MOV AX,[BX]
	MOV CLUSTER, AX
	RET		
DIR_ENT ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHECK_ENTRY PROC NEAR
	CMP ROOT_FLAG, 1
	JE FLIPENT
	CALL FILE_READER
	RET
	FLIPENT:
	CALL DIR_ENT
	RET
CHECK_ENTRY ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CHANGE_DIRECTORY PROC NEAR	
	XOR AH,AH
	MOV AL, SEC_PER_CLUS
	;MOVZX AX, SEC_PER_CLUS
	MOV CL,9
	SHL AX, CL
	
	XOR BX, BX
	
	CHKNEXT:
	CLD
	LEA SI, NAMEARG
	LEA DI, SEC_BUFFER[BX]
	MOV BP, DI
	MOV CX,11
	REPE CMPSB
	JE FOUNDSUB
	ADD BX, 32
	CMP BX, AX
	JNE CHKNEXT
	
	MOV FILE_FLAG,0
	RET
	
	FOUNDSUB:
	MOV FILE_FLAG, 1
	ADD BP,26
	MOV BX, BP
	MOV AX, [BX]
	MOV CLUSTER, AX
	RET	
CHANGE_DIRECTORY ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

FILE_READER PROC NEAR
	CMP CLUSTER, 0	;EMPTY, SIZE=0
	JE GETTODOS
	
	GONEXTCL:
	CALL CLUSTER_FINDER
	CMP DIR_FLAG, 1
	JE GOTOSUBDIR 
	CALL PRINT_BUFFER
	JMP COMCK
	GOTOSUBDIR:
	CALL CHANGE_DIRECTORY
	CMP FILE_FLAG,1
	JE RETVAL
	COMCK:
	CALL FAT_CLUS_ENT
	CMP CLUSTER, 0FFFH
	JNE GONEXTCL
	CMP DIR_FLAG, 1
	JNE RETVAL
	CMP FILE_FLAG, 0
	JNE RETVAL
	JMP ERRORPRN
	
	RETVAL:
	RET
	
	GETTODOS:
	MOV AX,4C00H
	INT 21H
FILE_READER ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

PRINT_BUFFER PROC NEAR
	MOV AH,3	;SET DH,DL
	MOV BH,0
	INT 10H
	
	MOV AH,13H
	MOV AL,1	
	LEA BP,SEC_BUFFER
	XOR BH,BH
	MOV BL, SEC_PER_CLUS
	MOV CL,9
	SHL BX,CL
	MOV CX,BX	;TOTAL CX
	
	CMP AS_BIN_FLAG, 1
	JNE PRINTBINARY
	
	MOV DI,BP
	CLD
	MOV AL,0
	REPNE SCASB
	SUB DI,BP
	DEC DI
	MOV CX,DI
	
	PRINTBINARY:
	MOV BH,0
	MOV BL,07
	INT 10H	

	RET
PRINT_BUFFER ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SET_INPUT PROC NEAR
	MOV AL, PATHLEN
	INC AL
	CMP AL, TKNPT
	JNE EVALUATE
	MOV DIR_FLAG, 0
	RET
	
	EVALUATE:
	CLD
	LEA DI,NAMEARG
	MOV AL,' '
	MOV CX,12
	REP STOSB
	
	XOR BX,BX
	XOR CH,CH
	MOV CL,TKNPT
	MOV SI, CX
	GETNTC:
	MOV AL, PATH[BX+SI]
	MOV PRT_FLAG , AL
	CMP AL, '\'
	JE OKB
	CMP AL, 0DH
	JE OKB
	MOV NAMEARG[BX], AL
	INC BX
	CMP BX,12
	JNE GETNTC
	
	OKB:
	INC BX
	ADD TKNPT, BL
	
	MOV DIR_FLAG, 1
	
	LEA DI, NAMEARG
	MOV CX,9
	MOV AL,'.'
	REPNE SCASB
	JNE GOFIN
	
	MOV BYTE PTR[DI-1], ' '
	MOV AL,[DI+2]
	MOV BL,[DI+1]
	MOV CL,[DI]		
	MOV SI, DI
	ADD SI,2
	CALL PUTSPACE	
	MOV NAMEARG+10, AL	
	MOV SI, DI
	INC SI
	CALL PUTSPACE
	MOV NAMEARG+9, BL	
	MOV SI, DI
	CALL PUTSPACE
	MOV NAMEARG+8, CL		
	MOV BYTE PTR NAMEARG+11,' '
	JMP GOFIN
	
	PUTSPACE:
	PUSH SI
	SUB SI, OFFSET NAMEARG
	CMP SI, 7
	JA GBSD
	POP SI
	MOV BYTE PTR[SI], ' '
	RET
	GBSD:
	POP SI
	RET
	
	GOFIN:
	RET
SET_INPUT ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ERRORPRN PROC NEAR
	MOV AH,9	
	CMP PRT_FLAG , 0DH
	JE FILERR
	LEA DX, DIRERROR
	JMP PRNT
	FILERR:
	LEA DX, FILEERROR
	
	PRNT:
	INT 21H	
	
	MOV AX,4C01H
	INT 21H
ERRORPRN ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

READERROR PROC NEAR
	MOV AH, 9
	LEA DX, FATALERROR
	INT 21H
	
	MOV AX,4C01H
	INT 21H
READERROR ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MAIN PROC NEAR   
	MOV AX, DATASEG
	MOV DS,AX
	PUSH DS
	
	MOV CL, ES:[80H]
	MOV PATHLEN, CL
	CMP CL, 1
	JBE ABFIN
	
	XOR BX, BX
	CHKSW:
	CMP BYTE PTR ES:[82H+BX], ' '
	JNE INCBDS
	CMP BYTE PTR ES:[82H+BX+1], '/'
	JNE INCBDS
	CMP BYTE PTR ES:[82H+BX+2], 'B'
	JE FOUNDSW
	CMP BYTE PTR ES:[82H+BX+2], 'b'
	JE FOUNDSW
	INCBDS:
	INC BX
	CMP BL, PATHLEN
	JNE CHKSW
	JMP GETFILE
	
	FOUNDSW:
	MOV DRIVE, 1
	MOV BYTE PTR ES:[82H+BX], 0DH
	INC BX
	MOV PATHLEN, BL
	
	GETFILE:
	XOR BX, BX
	FILLPATH:
	MOV CL, BYTE PTR ES:[82H+BX]
	MOV PATH[BX], CL
	INC BX
	CMP BL, PATHLEN
	JNE FILLPATH
	DEC PATHLEN
	
	POP ES
	
	XOR BX,BX
	CAPPATH:
	CMP PATH[BX], 61H
	JB ADBX
	CMP PATH[BX], 7AH
	JA ADBX
	AND PATH[BX],0DFH
	ADBX:
	INC BX
	CMP BL, PATHLEN
	JNE CAPPATH
	
	;SKIP DRIVE LETTER
	MOV AL, DRIVE
	OR AL, 41H
	CMP BYTE PTR PATH, AL
	JNE NO_DRIVE_DEFINED
	CMP BYTE PTR PATH+1, ':'
	JNE NO_DRIVE_DEFINED
	CMP BYTE PTR PATH+2, '\'
	JNE NO_DRIVE_DEFINED
	MOV TKNPT, 3
	
	NO_DRIVE_DEFINED:
	CALL BOOT_RECORD_READER
	
	CALL SET_INPUT
	MOV ROOT_FLAG,1
	CALL CHECK_ENTRY
	
	MOV ROOT_FLAG,0
	NEXTTOKEN:
	CALL SET_INPUT
	CALL CHECK_ENTRY
	CMP DIR_FLAG, 0
	JNE NEXTTOKEN
	JMP FINISH
	
	ABFIN:
	MOV AH,9
	LEA DX,PROMPT
	INT 21H
	
	FINISH:
	MOV AH,2
	MOV DL,10
	INT 21H
	MOV DL,13
	INT 21H
	
	MOV AX,4C00H
	INT 21H
MAIN ENDP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

CODESEG ENDS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

END MAIN

;;Copyright (c)  2004-2007 Artman(R) Systems Incorporated and its licensors. All rights reserved.